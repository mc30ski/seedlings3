generator client {
  provider = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum Role {
  WORKER
  ADMIN
  SUPER
}

enum EquipmentStatus {
  AVAILABLE
  RESERVED
  CHECKED_OUT
  MAINTENANCE
  RETIRED
}

enum AuditScope {
  USER
  EQUIPMENT
  CLIENT
  JOB
  PROPERTY
  // add more scopes as you expand the schema
}

enum AuditVerb {
  APPROVED
  ROLE_ASSIGNED
  ROLE_REMOVED
  CREATED
  UPDATED
  RETIRED
  UNRETIRED
  DELETED
  CHECKED_OUT
  RELEASED
  MAINTENANCE_START
  MAINTENANCE_END
  RESERVED
  RESERVATION_CANCELLED
  RETURNED
  FORCE_RELEASED
  PRIMARY_CONTACT_SET
  // add new verbs as needed
}

model User {
  id           String       @id @default(cuid())
  clerkUserId  String       @unique
  email        String?
  displayName  String?
  isApproved   Boolean      @default(false)

  roles        UserRole[]
  checkouts    Checkout[]
  auditEvents  AuditEvent[] @relation("AuditActor")

  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  jobDefaultAssignments     JobAssigneeDefault[]
  jobOccurrenceAssignments  JobOccurrenceAssignee[]
  jobAssignmentAuditActor   JobOccurrenceAssignee[] @relation("JobAssignActor")
}

model UserRole {
  id      String @id @default(cuid())
  userId  String
  role    Role

  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, role])
}

model Equipment {
  id         String           @id @default(uuid())
  qrSlug     String?          @unique
  status     EquipmentStatus  @default(AVAILABLE)
  type       String?
  brand      String?
  model      String?
  shortDesc  String?
  longDesc   String?
  energy     String?
  features   String?
  condition  String?
  issues     String?
  age        String?

  checkouts    Checkout[]

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  retiredAt  DateTime?
}

model Checkout {
  id           String   @id @default(cuid())
  equipmentId  String
  userId       String
  reservedAt   DateTime @default(now())
  checkedOutAt DateTime?
  releasedAt   DateTime?

  equipment    Equipment @relation(fields: [equipmentId], references: [id], onDelete: Cascade)
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Helpful indexes; the “one active checkout” guarantee is added via a partial unique index in SQL
  @@index([equipmentId, releasedAt])
  @@index([userId, checkedOutAt])
}

model AuditEvent {
  id           String       @id @default(cuid())

  scope        AuditScope
  verb         AuditVerb
  action       String?      @db.VarChar(64)

  actorUserId  String?
  metadata     Json?

  actor        User?        @relation("AuditActor", fields: [actorUserId], references: [id], onDelete: SetNull)

  createdAt    DateTime     @default(now())

  @@index([actorUserId, createdAt])
  @@index([scope, createdAt])
  @@index([verb, createdAt])
  @@index([scope, verb, createdAt])
}

enum ClientType {
  INDIVIDUAL
  HOUSEHOLD
  ORGANIZATION
  COMMUNITY
}

enum ClientStatus {
  ACTIVE
  PAUSED
  ARCHIVED
}

enum PropertyKind {
  SINGLE
  AGGREGATE_SITE
}

enum ContactRole {
  OWNER
  SPOUSE
  COMMUNITY_MANAGER
  PROPERTY_MANAGER
  BILLING
  TECHNICAL
  OPERATIONS
  LEGAL
  OTHER
}

enum ContactStatus {
  ACTIVE
  PAUSED
  ARCHIVED
}

enum PropertyStatus {
   PENDING
   ACTIVE
   ARCHIVED
}

model Client {
  id            String       @id @default(cuid())
  type          ClientType
  displayName   String

  status        ClientStatus @default(ACTIVE)

  notesInternal String?

  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  //TODO: NOT BEING USED YET, BUT SHOULD MAKE ALL ENTITIES BE RETIRED/ARCHIVED
  archivedAt    DateTime?

  // Relations
  contacts      ClientContact[]
  properties    Property[]
  jobClients    JobClient[]

  @@index([status])
  @@index([displayName])
}

model ClientContact {
  id               String      @id @default(cuid())

  status           ContactStatus @default(ACTIVE)

  // Belongs to Client
  clientId         String
  client           Client      @relation(fields: [clientId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  // Identity
  firstName        String
  lastName         String
  email            String?
  phone            String?                 // raw as entered
  normalizedPhone  String?     @db.VarChar(20) // E.164 for dedupe/lookup

  role             ContactRole?
  isPrimary        Boolean     @default(false)

  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  propertiesAsPOC  Property[]  @relation("PropertyPOC")

  // Backref from Property.pointOfContactId targets this model

  jobContacts JobContact[]

  @@index([clientId, status])
  // Postgres allows multiple NULLs in UNIQUE constraints—works for optional fields:
  @@unique([email])
  @@unique([normalizedPhone])
}

model Property {
  id                 String         @id @default(cuid())

  // Belongs to Client
  clientId           String
  client             Client         @relation(fields: [clientId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  kind               PropertyKind   @default(SINGLE)

  // Labels & addressing
  displayName        String
  street1            String
  street2            String?
  city               String
  state              String
  postalCode         String
  country            String

  // Optional geo
  //lat                Float?
  //lng                Float?
  //geohash            String

  // Aggregate-site (community) fields (optional)
  //unitLabel          String?        // e.g., "home", "lot", "unit"
  //unitCount          Int?
  //siteName           String?
  //siteBoundaryGeo    Json?          // polygon/bbox later if needed

  // Default point of contact for this property
  pointOfContactId   String?
  pointOfContact     ClientContact? @relation("PropertyPOC", fields: [pointOfContactId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  // Light ops
  accessNotes        String?
  //photos             Json?

  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  archivedAt         DateTime?

  status            PropertyStatus @default(PENDING)

  jobs              Job[]

  @@index([clientId])
  @@index([kind])
}

// ----- Post-MVP: per-unit granularity inside aggregate-site Properties -----
// model PropertyUnit {
//   id            String   @id @default(cuid())
//   propertyId    String
//   property      Property @relation(fields: [propertyId], references: [id], onDelete: Cascade, onUpdate: Cascade)
//   label         String   // or unitNumber
//   entranceNotes String?
//   gateCode      String?
//   active        Boolean  @default(true)
//   createdAt     DateTime @default(now())
//   updatedAt     DateTime @updatedAt
//   @@index([propertyId, active])
// }

enum JobKind {
  ENTIRE_SITE
  SINGLE_ADDRESS
}

enum JobStatus {
  PROPOSED
  ACCEPTED
}

enum Cadence {
  WEEKLY
  BIWEEKLY
  MONTHLY
}

enum JobOccurrenceStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELED
}

enum JobOccurrenceSource {
  GENERATED
  MANUAL
}

model Job {
  id          String    @id @default(cuid())

  propertyId  String
  property    Property  @relation(fields: [propertyId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  kind        JobKind   @default(SINGLE_ADDRESS) // REQUIRED
  status      JobStatus @default(PROPOSED)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  contacts    JobContact[]
  clients     JobClient[]

  schedule          JobSchedule?
  occurrences       JobOccurrence[]
  defaultAssignees  JobAssigneeDefault[]
}

model JobContact {
  id              String         @id @default(cuid())

  jobId           String
  job             Job            @relation(fields: [jobId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  clientContactId String
  clientContact   ClientContact  @relation(fields: [clientContactId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  role            String         // "decision_maker" | "on_site" | "notify_only"
  notify          Boolean        @default(true)

  @@index([jobId])
  @@index([clientContactId])
}

model JobClient {
  id        String   @id @default(cuid())

  jobId     String
  job       Job      @relation(fields: [jobId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  clientId  String
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  role      String   // "owner" | "payer" | "point_of_contact"
  share     Float?   // optional split %

  @@index([jobId])
  @@index([clientId])
}

model JobSchedule {
  id        String  @id @default(cuid())

  jobId     String  @unique
  job       Job     @relation(fields: [jobId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  autoRenew Boolean @default(false)

  cadence   Cadence?
  interval  Int?       // every N weeks/months (simple)

  dayOfWeek Int?       // 0-6 for weekly-ish schedules
  dayOfMonth Int?      // 1-31 for monthly-ish schedules

  preferredStartHour Int?
  preferredEndHour   Int?

  horizonDays    Int      @default(21)
  nextGenerateAt DateTime?
  active         Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model JobOccurrence {
  id          String   @id @default(cuid())

  jobId       String
  job         Job      @relation(fields: [jobId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  kind        JobKind  // REQUIRED (copied from Job.kind on creation, editable later)

  windowStart DateTime?
  windowEnd   DateTime?
  startAt     DateTime?
  endAt       DateTime?

  status      JobOccurrenceStatus @default(SCHEDULED)
  source      JobOccurrenceSource @default(GENERATED)

  notes       String?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  assignees   JobOccurrenceAssignee[]

  @@index([jobId, status])
  @@index([startAt])
  @@index([kind])
}

model JobAssigneeDefault {
  id        String   @id @default(cuid())

  jobId     String
  job       Job      @relation(fields: [jobId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  role      String?  // optional: "primary" | "helper"
  active    Boolean  @default(true)

  createdAt DateTime @default(now())

  @@unique([jobId, userId])
  @@index([jobId, active])
  @@index([userId])
}

model JobOccurrenceAssignee {
  id            String        @id @default(cuid())

  occurrenceId  String
  occurrence    JobOccurrence @relation(fields: [occurrenceId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  role          String?
  assignedAt    DateTime      @default(now())

  assignedById  String?
  assignedBy    User?         @relation("JobAssignActor", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([occurrenceId, userId])
  @@index([occurrenceId])
  @@index([userId])
  @@index([assignedById])
}