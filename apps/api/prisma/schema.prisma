generator client {
  provider = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

enum Role {
  WORKER
  ADMIN
  SUPER
}

enum EquipmentStatus {
  AVAILABLE
  RESERVED
  CHECKED_OUT
  MAINTENANCE
  RETIRED
}

enum AuditScope {
  USER
  EQUIPMENT
  CLIENT
  JOB
  // add more scopes as you expand the schema
}

enum AuditVerb {
  APPROVED
  ROLE_ASSIGNED
  CREATED
  UPDATED
  RETIRED
  DELETED
  CHECKED_OUT
  RELEASED
  MAINTENANCE_START
  MAINTENANCE_END
  RESERVED
  RESERVATION_CANCELLED
  RETURNED
  FORCE_RELEASED
  // add new verbs as needed
}

model User {
  id           String       @id @default(cuid())
  clerkUserId  String       @unique
  email        String?
  displayName  String?
  isApproved   Boolean      @default(false)

  roles        UserRole[]
  checkouts    Checkout[]
  auditEvents  AuditEvent[] @relation("AuditActor")

  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
}

model UserRole {
  id      String @id @default(cuid())
  userId  String
  role    Role

  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, role])
}

model Equipment {
  id         String           @id @default(uuid())
  qrSlug     String?          @unique
  status     EquipmentStatus  @default(AVAILABLE)
  type       String?
  brand      String?
  model      String?
  shortDesc  String?
  longDesc   String?
  energy     String?
  features   String?
  condition  String?
  issues     String?
  age        String?

  checkouts    Checkout[]
  auditEvents  AuditEvent[]     @relation("AuditEquipment")

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  retiredAt  DateTime?
}

model Checkout {
  id           String   @id @default(cuid())
  equipmentId  String
  userId       String
  reservedAt   DateTime @default(now())
  checkedOutAt DateTime?
  releasedAt   DateTime?

  equipment    Equipment @relation(fields: [equipmentId], references: [id], onDelete: Cascade)
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Helpful indexes; the “one active checkout” guarantee is added via a partial unique index in SQL
  @@index([equipmentId, releasedAt])
  @@index([userId, checkedOutAt])
}

model AuditEvent {
  id           String       @id @default(cuid())

  scope        AuditScope
  verb         AuditVerb

  // Optional convenience string (e.g., "EQUIPMENT_CREATED")
  action       String?      @db.VarChar(64)

  actorUserId  String?
  equipmentId  String?
  metadata     Json?

  actor        User?        @relation("AuditActor", fields: [actorUserId], references: [id], onDelete: SetNull)
  equipment    Equipment?   @relation("AuditEquipment", fields: [equipmentId], references: [id], onDelete: SetNull)

  createdAt    DateTime     @default(now())

  @@index([equipmentId, createdAt])
  @@index([actorUserId, createdAt])
  @@index([scope, createdAt])
  @@index([verb, createdAt])
  @@index([scope, verb, createdAt])
}